# Vulnerability Scanning Plan for WSO2 API Manager

## Table of Contents

1. [Codebase Context](#1-codebase-context)
2. [Attack Surface Summary](#2-attack-surface-summary)
3. [Tool Evaluation Matrix](#3-tool-evaluation-matrix)
4. [Recommended Approach: Layered Scanning Strategy](#4-recommended-approach-layered-scanning-strategy)
5. [Option A: Open-Source Stack](#option-a-open-source-stack-0year)
6. [Option B: Mid-Tier Commercial + Open-Source Hybrid](#option-b-mid-tier-commercial--open-source-hybrid)
7. [Option C: Enterprise Commercial Stack](#option-c-enterprise-commercial-stack)
8. [Encoding Past Vulnerability Examples (Custom Rules)](#6-encoding-past-vulnerability-examples-custom-rules)
9. [Multi-Repository Scanning Strategy](#7-multi-repository-scanning-strategy)
10. [CI/CD Integration Architecture](#8-cicd-integration-architecture)
11. [Coverage Gap Analysis](#9-coverage-gap-analysis)
12. [Recommendation](#10-recommendation)

---

## 1. Codebase Context

Based on analysis of the `product-apim` repository:

| Dimension                | Details |
|--------------------------|---------|
| **Primary Language**     | Java (source 1.8 compat, CI runs JDK 11) |
| **Build System**         | Maven multi-module (4 top-level modules: api-control-plane, gateway, traffic-manager, all-in-one-apim) |
| **Frameworks**           | Spring 5.1.x, Apache CXF 3.6.x (JAX-RS), Axis2, Apache Synapse, Tomcat Embedded |
| **ORM / DB Access**      | Hibernate, JDBC (H2 dev, multiple datasources: WSO2_CARBON_DB, WSO2AM_DB, WSO2AM_STATS_DB, WSO2_SHARED_DB) |
| **Auth/AuthZ**           | OAuth2, OIDC, SAML 2.0, Mutual TLS, JWT (Nimbus JOSE), Carbon Identity Framework |
| **XML Parsing**          | AXIOM, JAXB, StAX (via Axis2), Apache Santuario, OpenSAML |
| **Existing Security**    | OWASP CSRFGuard (configured), WSS4J, Bouncy Castle, Apache XML Security |
| **CI/CD**                | GitHub Actions (maven.yml), Codecov for coverage |
| **Dependent Repos**      | 5-15 WSO2 component repositories pulled via Maven (carbon-apimgt, carbon-identity-framework, etc.) |
| **JSON Libraries**       | Jackson 2.16.x, Gson, JSON-Simple, JSON-Smart, JSONPath |
| **HTTP Clients**         | OkHttp 4.12, Apache HttpClient, Jersey |

---

## 2. Attack Surface Summary

Given the architecture, these are the priority vulnerability classes to scan for:

### Tier 1 - Critical (Direct exploit paths in an API Gateway)

| Vulnerability         | Where It Lives in This Codebase |
|-----------------------|-------------------------------|
| **SQL Injection**     | JDBC calls in Carbon DB layer, custom DAO classes, Hibernate HQL. Multiple datasources with raw connection pools. |
| **XXE Injection**     | AXIOM/JAXB/StAX XML parsing in SOAP handlers (Axis2), SAML assertion processing (OpenSAML), API payload mediation (Synapse). |
| **SSRF**              | API Gateway proxying, backend endpoint calls via OkHttp/HttpClient, mediation sequences. |
| **Auth Bypass / Privilege Escalation** | OAuth2 token validation logic, scope enforcement, role checks in Carbon Identity, API key validation. |
| **Insecure Deserialization** | Java object deserialization in message passing, OSGI bundle communication, Axis2 SOAP handling. |

### Tier 2 - High

| Vulnerability         | Where It Lives |
|-----------------------|---------------|
| **CSRF**              | CSRFGuard is configured but coverage gaps may exist (unprotected endpoints, token validation bypasses). |
| **XSS**               | Admin/Publisher/DevPortal UIs (JSP, JavaScript), error messages reflected in responses. |
| **Path Traversal**    | File-based API artifact storage, deployment artifact handling, log file access. |
| **LDAP Injection**    | User store lookups via Carbon User Manager. |

### Tier 3 - Medium

| Vulnerability         | Where It Lives |
|-----------------------|---------------|
| **Hardcoded Secrets** | Configuration files, test fixtures, embedded credentials. |
| **Weak Cryptography** | Bouncy Castle usage, TLS configuration, token signing algorithms. |
| **Race Conditions**   | Concurrent API subscription handling, token revocation. |
| **Known CVEs in Dependencies** | 100+ transitive dependencies via Maven, many WSO2-patched forks. |

---

## 3. Tool Evaluation Matrix

### SAST Tools (Source Code Analysis)

| Tool | Analysis Type | Cross-File Taint | Custom Rules | Java Quality | Cost | Best For |
|------|:------------:|:----------------:|:------------:|:------------:|------|----------|
| **Semgrep Pro** | Semantic + Pattern | Yes (Pro) | Yes (YAML DSL) | Very High | Free CE; $40/dev/mo | Best balance of power, usability, and cost |
| **CodeQL** | Full Semantic (DB-based) | Yes | Yes (QL language) | Excellent | Free (public repos) / GHAS | Deepest free semantic analysis |
| **SonarQube** | Semantic + Taint | Yes (Dev+) | Limited (src/sink config) | Very High | Free Community; $2.5K+/yr Dev | Code quality + security in one |
| **Snyk Code** | AI/ML Semantic | Yes | No | Good | Free limited; $25/dev/mo | AI-driven novel pattern detection |
| **Checkmarx One** | Full Semantic | Yes | Yes (CxQL + AI Builder) | Excellent | ~$59K+/yr | Enterprise, compliance-driven orgs |
| **Fortify** | Full Semantic | Yes | Yes (XML rules) | Excellent | Enterprise (contact sales) | Regulated industries, gov compliance |
| **SpotBugs + FindSecBugs** | Bytecode Pattern | No (intra-method only) | Yes (Java API) | Excellent | Free (LGPL) | Free baseline, catches low-hanging fruit |
| **Joern** | Code Property Graph | Yes | Yes (Scala DSL) | Good | Free (Apache 2.0) | Research, novel vuln discovery |

### SCA Tools (Dependency Scanning) - Complementary Layer

| Tool | What It Scans | Custom Rules | Cost |
|------|---------------|:------------:|------|
| **OWASP Dependency-Check** | Maven deps against NVD | Suppression files only | Free |
| **Trivy** | Deps, containers, IaC, secrets | Rego (IaC only) | Free |
| **Snyk Open Source** | Deps with reachability analysis | No | Free limited; paid tiers |

---

## 4. Recommended Approach: Layered Scanning Strategy

No single tool covers everything. The recommended approach layers tools by analysis depth:

```
 Layer 4: Custom/Research Analysis (for historical vuln patterns)
           Joern (CPG) or Semgrep Custom Rules or CodeQL Custom Queries
          ┌─────────────────────────────────────────────────────────┐
 Layer 3: │ Deep Semantic SAST (cross-file taint analysis)         │
          │ Semgrep Pro  OR  CodeQL  OR  SonarQube Dev+            │
          ├─────────────────────────────────────────────────────────┤
 Layer 2: │ Bytecode-Level Security Scanning                       │
          │ SpotBugs + Find Security Bugs (free, 144 vuln types)   │
          ├─────────────────────────────────────────────────────────┤
 Layer 1: │ Dependency / SCA Scanning                              │
          │ OWASP Dependency-Check + Trivy                         │
          └─────────────────────────────────────────────────────────┘
```

Each layer catches different things:
- **Layer 1** catches known CVEs in your 100+ transitive dependencies (especially critical given WSO2-patched forks)
- **Layer 2** catches common patterns in compiled bytecode (cheap, fast, zero false-negative baseline)
- **Layer 3** finds complex multi-step vulnerabilities where tainted data flows across classes and packages
- **Layer 4** encodes your organization's past vulnerability examples into reusable detection rules

---

## Option A: Open-Source Stack ($0/year)

**Tools: CodeQL + SpotBugs/FindSecBugs + OWASP Dependency-Check + Trivy**

### Strengths
- **CodeQL** provides full cross-file taint analysis with the industry's most expressive custom query language (QL). Covers SQL injection, XXE, SSRF, deserialization, CSRF, and more out of the box. Excellent Java support including Spring/JAX-RS library models.
- **SpotBugs + Find Security Bugs** adds fast bytecode scanning (144 vuln types, 826+ API signatures) as a Maven build step. Catches issues CodeQL might miss at the bytecode level.
- **OWASP Dependency-Check** scans all Maven dependencies against NVD. Critical for a project with many WSO2-forked dependencies.
- **Trivy** adds container image scanning and secrets detection.

### Weaknesses
- CodeQL requires GitHub Advanced Security for private repos (free for public repos only). If product-apim is private, this becomes the GHAS pricing tier.
- CodeQL build times can be significant for large codebases (15-45 min for a codebase this size).
- No AI/ML-driven detection - all rules are hand-authored.
- Custom CodeQL queries have a steep learning curve (QL is a logic programming language).

### Coverage for Target Vulnerability Classes

| Vulnerability | CodeQL | FindSecBugs | OWASP DC | Combined |
|---------------|:------:|:-----------:|:--------:|:--------:|
| SQL Injection | Deep taint tracking across DAO layers | Intra-method JDBC/HQL patterns | Known CVEs in DB drivers | Strong |
| XXE           | Tracks XML parser config to parse calls | Detects unsafe XMLReader/DocumentBuilder | Known CVEs in XML libs | Strong |
| SSRF          | Tracks user input to HTTP client calls | Limited (no cross-method) | Known CVEs in HTTP libs | Moderate-Strong |
| Privilege Escalation | Custom queries needed for auth logic | Not covered | N/A | Requires custom work |
| CSRF          | Detects missing CSRF tokens | Partial detection | N/A | Moderate |
| Deserialization | ObjectInputStream tracking | Detects unsafe deserialization calls | Known CVEs (e.g., Commons Collections) | Strong |
| XSS           | Cross-file source-to-sink | Intra-method reflection | N/A | Strong |
| Path Traversal | User input to file operations | Basic pattern matching | N/A | Moderate-Strong |

### Effort to Set Up
- CodeQL: ~2-3 days (GitHub Actions workflow, initial query tuning, suppression of false positives)
- SpotBugs: ~1 day (Maven plugin config, threshold tuning)
- OWASP Dependency-Check: ~0.5 day (Maven plugin, NVD API key)
- Trivy: ~0.5 day (CI step for container images)
- Custom CodeQL queries for past vulns: ~1-2 weeks per vulnerability class

---

## Option B: Mid-Tier Commercial + Open-Source Hybrid

**Tools: Semgrep Pro (Team) + SonarQube Developer + SpotBugs/FindSecBugs + OWASP Dependency-Check**

### Strengths
- **Semgrep Pro** (Team tier, $40/contributor/month, free for <=10) provides cross-file taint analysis with the most accessible custom rule language (YAML-based, looks like source code). Writing custom rules from past vulnerability examples is significantly easier than CodeQL's QL.
- **SonarQube Developer** ($2,500+/yr) adds continuous code quality + security analysis with branch/PR analysis, quality gates, and a developer-friendly dashboard. Its taint engine is strong for Java.
- **SpotBugs + FindSecBugs** as a free bytecode baseline (same as Option A).
- **OWASP Dependency-Check** for SCA (same as Option A).

### Strengths Over Option A
- Semgrep's custom rule authoring is 5-10x faster than CodeQL for encoding historical vulnerability patterns
- SonarQube provides a single dashboard for both security and code quality, with trend tracking over time
- Semgrep's rules look like the source code they match - easier for Java developers to write and review
- Faster scan times (Semgrep: seconds to minutes; SonarQube: minutes)
- No dependency on GitHub (works with any Git hosting)

### Weaknesses
- Total cost: ~$5,000-15,000/year depending on team size and LOC
- SonarQube's custom rule capability is limited compared to Semgrep/CodeQL (can only configure sources/sinks, not arbitrary patterns)
- Some overlap between Semgrep Pro and SonarQube security rules (both detect SQL injection, XXE, etc.)

### Coverage for Target Vulnerability Classes

| Vulnerability | Semgrep Pro | SonarQube Dev | FindSecBugs | Combined |
|---------------|:-----------:|:-------------:|:-----------:|:--------:|
| SQL Injection | Cross-file taint, Spring/JDBC models | Cross-file taint | Intra-method | Very Strong |
| XXE           | Custom rules for AXIOM/JAXB/StAX | Built-in rules | Parser config detection | Very Strong |
| SSRF          | HTTP client sink tracking | Built-in rules | Limited | Strong |
| Privilege Escalation | Custom rules for auth patterns | Limited | Not covered | Moderate (custom) |
| CSRF          | Custom rules for endpoint protection | Built-in rules | Partial | Strong |
| Deserialization | Taint tracking to deserialization sinks | Built-in rules | Pattern detection | Very Strong |
| XSS           | Cross-file taint | Cross-file taint | Intra-method | Very Strong |
| Path Traversal | File operation sink tracking | Built-in rules | Pattern matching | Very Strong |

### Effort to Set Up
- Semgrep Pro: ~1-2 days (CI integration, rule selection, team onboarding)
- SonarQube Dev: ~2-3 days (server setup, project config, quality profiles, PR decoration)
- SpotBugs: ~1 day (Maven plugin)
- OWASP Dependency-Check: ~0.5 day
- Custom Semgrep rules for past vulns: ~2-5 days per vulnerability class (much faster than CodeQL)

---

## Option C: Enterprise Commercial Stack

**Tools: Checkmarx One OR Fortify + Snyk (Code + Open Source) + Trivy**

### Strengths
- **Checkmarx One** or **Fortify** provides the deepest commercial SAST with the widest vulnerability coverage (1,400+ categories), cross-file taint analysis, and enterprise features (compliance reporting, RBAC, SSO).
- **Checkmarx CxQL + AI Query Builder**: Write custom queries in a dedicated language or describe patterns in natural language and let AI generate the query. Best commercial option for encoding past vulnerability examples.
- **Snyk Code** adds AI/ML-driven detection trained on 25M+ real-world dataflow cases. This is the only tool that genuinely learns vulnerability patterns from historical data (not rule-authored).
- **Snyk Open Source** provides SCA with reachability analysis (tells you if your code actually calls the vulnerable function, not just that you depend on the library).
- **Trivy** for container/IaC scanning.

### Strengths Over Options A & B
- Widest vulnerability coverage (1,400+ categories vs ~144 for FindSecBugs)
- Compliance reporting out of the box (OWASP Top 10, PCI DSS, NIST 800-53, CWE Top 25)
- Snyk Code's AI can detect novel vulnerability variants that no rule-based system would catch
- Checkmarx's AI Query Builder converts natural-language vulnerability descriptions into detection rules
- Professional support, SLAs, and dedicated security research teams maintaining rules
- Fine-grained RBAC, audit trails, and policy enforcement for enterprise security programs

### Weaknesses
- Significant cost: Checkmarx ~$59K+/year, Fortify (contact sales, comparable), Snyk Enterprise ~$10K-70K+/year
- Vendor lock-in concerns (proprietary query languages, proprietary results formats)
- Longer procurement cycles
- Heavier infrastructure requirements

### Coverage for Target Vulnerability Classes

| Vulnerability | Checkmarx/Fortify | Snyk Code | Combined |
|---------------|:-----------------:|:---------:|:--------:|
| SQL Injection | Deep taint, framework-aware | AI-detected patterns | Comprehensive |
| XXE           | Full parser analysis | AI-detected patterns | Comprehensive |
| SSRF          | Full HTTP client tracking | AI-detected patterns | Comprehensive |
| Privilege Escalation | Auth flow analysis + custom CxQL | AI-detected patterns | Strong |
| CSRF          | Framework-aware detection | AI-detected patterns | Strong |
| Deserialization | Deep tracking | AI-detected patterns | Comprehensive |
| XSS           | Full taint analysis | AI-detected patterns | Comprehensive |
| Path Traversal | Full taint analysis | AI-detected patterns | Comprehensive |

### Effort to Set Up
- Checkmarx/Fortify: ~1-2 weeks (procurement, installation, initial scan tuning, false positive triage)
- Snyk: ~1-2 days (SaaS, SCM integration, policy config)
- Trivy: ~0.5 day
- Custom Checkmarx queries: ~1-3 days per vulnerability class (CxQL + AI Query Builder)

---

## 6. Encoding Past Vulnerability Examples (Custom Rules)

This is a critical requirement. Here's how each tool approach handles it:

### Approach 1: Semgrep Custom Rules (Best for accessibility)

Semgrep rules look like the source code they match. Example for a historical SQL injection pattern:

```yaml
rules:
  - id: wso2-sqli-dao-pattern
    message: >
      Unsanitized input from $SOURCE reaches SQL query in DAO layer.
      This matches the pattern from VULN-2024-001.
    severity: ERROR
    languages: [java]
    mode: taint
    options:
      interfile: true
    pattern-sources:
      - patterns:
          - pattern: (HttpServletRequest $REQ).getParameter(...)
      - patterns:
          - pattern: (MessageContext $CTX).getProperty(...)
    pattern-sinks:
      - patterns:
          - pattern: (PreparedStatement $STMT).executeQuery($QUERY)
          # Or raw string concatenation into SQL
      - patterns:
          - pattern: |
              String $QUERY = ... + $TAINTED + ...;
              ...
              $CONN.prepareStatement($QUERY);
    pattern-sanitizers:
      - patterns:
          - pattern: Encoder.forSql(...)
```

**Workflow for encoding past vulnerabilities:**
1. Take the CVE/bug report with the vulnerable code path
2. Identify the source (where user input enters), sink (where the dangerous operation happens), and any missing sanitizer
3. Write a Semgrep taint-mode rule capturing that pattern
4. Test against the known-vulnerable code to confirm detection
5. Add to a private rule registry shared across all repos

**Estimated effort**: 2-4 hours per vulnerability pattern for an engineer familiar with Semgrep.

### Approach 2: CodeQL Custom Queries (Most powerful, steepest learning curve)

```ql
/**
 * @name SQL injection in WSO2 DAO layer
 * @description Detects unsanitized data flowing from HTTP request
 *              parameters to SQL queries via DAO classes.
 * @kind path-problem
 * @problem.severity error
 * @id wso2/sql-injection-dao
 */
import java
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.FlowSources

class DaoSqlInjection extends TaintTracking::Configuration {
  DaoSqlInjection() { this = "DaoSqlInjection" }

  override predicate isSource(DataFlow::Node source) {
    source instanceof RemoteFlowSource
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess ma |
      ma.getMethod().hasName("executeQuery") and
      ma.getMethod().getDeclaringType().hasQualifiedName("java.sql", "Statement") and
      sink.asExpr() = ma.getArgument(0)
    )
  }
}

from DaoSqlInjection config, DataFlow::PathNode source, DataFlow::PathNode sink
where config.hasFlowPath(source, sink)
select sink.getNode(), source, sink,
  "SQL injection: user input from $@ flows to SQL query.",
  source.getNode(), "this user input"
```

**Estimated effort**: 1-2 days per vulnerability pattern for an engineer new to QL; 2-4 hours once proficient.

### Approach 3: Joern CPG Queries (Most flexible, research-oriented)

```scala
// Find paths from HTTP input to SQL execution
val sources = cpg.method.name("getParameter").callIn
val sinks = cpg.method.name("executeQuery").callIn
sinks.reachableBy(sources).flows.l
```

**Best for**: Exploratory analysis when you don't know exactly what pattern to look for. The interactive REPL lets you navigate the code property graph and discover vulnerability variants.

**Estimated effort**: Variable. Very fast for ad-hoc exploration (minutes), longer for production-quality rules.

### Approach 4: Checkmarx AI Query Builder (Easiest for non-experts)

Natural language input:
> "Detect when data from an HTTP request parameter flows into a JDBC PreparedStatement that is constructed with string concatenation instead of parameterized queries, across multiple classes in the org.wso2.carbon.apimgt package."

The AI generates a CxQL query. Requires Checkmarx One license.

### Recommendation for Custom Rules

| If you choose... | Use this for custom rules | Learning curve | Rule authoring speed |
|-------------------|---------------------------|:--------------:|:--------------------:|
| Option A (OSS)    | CodeQL custom queries     | Steep (QL)     | Slow initially       |
| Option B (Hybrid) | Semgrep custom rules      | Low (YAML+Java patterns) | Fast          |
| Option C (Enterprise) | CxQL + AI Query Builder | Low-Medium  | Fast                 |

---

## 7. Multi-Repository Scanning Strategy

The product-apim codebase depends on 5-15 WSO2 component repositories (carbon-apimgt, carbon-identity-framework, carbon-kernel, etc.). Vulnerabilities often span repository boundaries - e.g., user input enters through product-apim but hits a dangerous sink in carbon-apimgt.

### Strategy 1: Mono-Scan (Scan Dependencies As Source)

```
┌─────────────────────────────────────────────────┐
│ Build product-apim (mvn install)                │
│ → All dependency source JARs resolved           │
│ → Feed entire classpath to scanner              │
│                                                 │
│ CodeQL:  Builds database from all resolved code │
│ Semgrep: Scans source dirs + dependency sources │
│ Fortify: Translates all source in classpath     │
└─────────────────────────────────────────────────┘
```

**Pros**: Catches cross-repository taint flows. A single scan.
**Cons**: Very large scan scope, longer scan times. Requires source JARs for all deps.

### Strategy 2: Per-Repo Scan with Shared Configuration

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ product-apim │  │carbon-apimgt │  │carbon-identity│
│   + rules    │  │   + rules    │  │   + rules    │
│   + config   │  │   + config   │  │   + config   │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └────────┬────────┴────────┬────────┘
                │                 │
         ┌──────┴──────┐  ┌──────┴──────┐
         │ Shared Rule │  │ Central     │
         │ Repository  │  │ Dashboard   │
         └─────────────┘  └─────────────┘
```

**Pros**: Faster per-scan. Each repo team owns their findings. Scales independently.
**Cons**: Misses cross-repository taint flows. Requires a shared rules repo.

### Strategy 3: Hybrid (Recommended)

- **Per-repo scans** (Strategy 2) for fast CI feedback on every PR
- **Periodic mono-scans** (Strategy 1, e.g., weekly/nightly) for cross-repo flow analysis
- **Shared custom rule repository** versioned and distributed to all repos
- **Central dashboard** (SonarQube, Semgrep AppSec Platform, or GitHub Security Overview) for aggregate view

---

## 8. CI/CD Integration Architecture

Building on the existing GitHub Actions workflow (`maven.yml`):

```yaml
# .github/workflows/security-scan.yml (conceptual)
name: Security Scanning

on:
  pull_request:
    branches: [master]
  schedule:
    - cron: '0 2 * * 1'  # Weekly deep scan (Monday 2am)

jobs:
  # Layer 1: Dependency scanning (fast, ~2-5 min)
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'product-apim'
          path: '.'
          format: 'HTML'
          args: '--failOnCVSS 7'
      - name: Trivy filesystem scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          severity: 'CRITICAL,HIGH'

  # Layer 2: Bytecode scan (medium, ~5-10 min, runs after build)
  spotbugs-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build and run SpotBugs + FindSecBugs
        run: mvn clean compile spotbugs:check -Dspotbugs.plugins=com.h3xstream.findsecbugs:findsecbugs-plugin

  # Layer 3: Semantic SAST (choose one based on option)
  semgrep-scan:  # Option B
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/java
            p/owasp-top-ten
            .semgrep/  # Custom rules directory
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

  codeql-scan:  # Option A
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    steps:
      - uses: actions/checkout@v4
      - uses: github/codeql-action/init@v3
        with:
          languages: java
          queries: security-extended,./codeql-queries/  # Custom query packs
      - uses: github/codeql-action/autobuild@v3
      - uses: github/codeql-action/analyze@v3

  # Layer 4: Nightly deep scan (cross-repo, historical patterns)
  deep-scan:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout all WSO2 component repos
        run: |
          # Clone dependent repos for cross-repo analysis
          # Run Joern CPG analysis or expanded Semgrep/CodeQL scan
```

### Gate Strategy

| Scan Layer | PR Gate? | Failure Behavior |
|------------|:--------:|------------------|
| Dependency (CVSS >= 7) | Yes, blocking | Fail PR check |
| SpotBugs (HIGH/CRITICAL) | Yes, blocking | Fail PR check |
| Semantic SAST (new findings only) | Yes, blocking on CRITICAL; warning on HIGH | Annotate PR, block on critical |
| Deep cross-repo scan | No (nightly) | Create Jira tickets / GitHub issues |

---

## 9. Coverage Gap Analysis

Even with the best tooling, some vulnerability classes need manual attention:

| Gap | Why Tools Struggle | Mitigation |
|-----|-------------------|------------|
| **Business logic privilege escalation** | Tools can track data flow but can't understand authorization intent (e.g., "only admin should access this endpoint") | Custom rules encoding specific auth patterns + manual code review of auth-related changes |
| **CSRF in single-page-app flows** | CSRFGuard is configured but SPA token refresh patterns are hard to model statically | Manual review of SPA API calls + integration tests verifying CSRF token enforcement |
| **Race conditions in token handling** | Static analysis cannot reason about concurrent execution timing | Concurrency-focused code review + targeted dynamic testing (DAST) |
| **Configuration-based vulnerabilities** | XML configs (datasources, security configs) may introduce vulns not visible in code | Config scanning rules (Semgrep can match XML patterns), Trivy misconfiguration scanning |
| **WSO2-specific auth bypass patterns** | Generic tools don't understand WSO2 Carbon's custom auth pipeline | Custom rules based on historical WSO2 CVEs (this is where your past vulnerability examples are critical) |

### Recommended Supplementary Measures

1. **DAST (Dynamic Application Security Testing)**: Run OWASP ZAP or Burp Suite against deployed instances for runtime validation
2. **Manual Penetration Testing**: Annual or per-release for business logic and auth bypass
3. **Threat Modeling**: Document data flows and trust boundaries for the API Gateway, especially auth token flows
4. **Security-Focused Code Review Checklist**: For PRs touching auth, XML parsing, SQL, or HTTP client code

---

## 10. Recommendation

### For most teams: Option B (Semgrep Pro + SonarQube Dev + SpotBugs + OWASP DC)

**Why:**
1. **Custom rules from past vulns are easiest in Semgrep** - YAML rules look like source code, can be authored by Java developers without learning a new language
2. **SonarQube provides a unified quality + security dashboard** with trend tracking, which helps track remediation progress across all repos
3. **SpotBugs is free and catches low-hanging fruit** that the other tools might skip at the bytecode level
4. **Cost is reasonable**: ~$5K-15K/year depending on team size, vs $60K+ for enterprise tools
5. **Fast feedback loop**: Semgrep scans in seconds on PRs; SonarQube in minutes

### If budget is zero: Option A (CodeQL + SpotBugs + OWASP DC)

CodeQL is the most powerful free semantic analysis tool. The learning curve for custom QL queries is steep but the expressiveness is unmatched. If the codebase is public or you have GitHub Advanced Security, this is the strongest free option.

### If compliance/regulation demands it: Option C (Checkmarx + Snyk)

For organizations with PCI DSS, SOC 2, or regulatory requirements that mandate specific SAST tooling, Checkmarx or Fortify provide the compliance reporting and audit trails needed. Snyk Code's AI adds a unique detection layer that no other tool provides.

### Phased Rollout Plan

| Phase | Timeline | Actions |
|-------|----------|---------|
| **Phase 1** | Week 1-2 | Add OWASP Dependency-Check + SpotBugs/FindSecBugs to CI (free, immediate value) |
| **Phase 2** | Week 3-4 | Add Semgrep CE or CodeQL to CI for semantic scanning. Begin writing custom rules from past vulnerability examples. |
| **Phase 3** | Month 2 | Evaluate Semgrep Pro or SonarQube Developer for cross-file taint analysis. Run trial scans, measure false positive rate. |
| **Phase 4** | Month 3 | Roll out to all dependent repositories with shared rule configuration. Set up central dashboard. |
| **Phase 5** | Ongoing | Encode each new vulnerability discovered into custom rules. Build organizational vulnerability knowledge base. |

---

## Appendix: Quick Reference - Tool Installation

### SpotBugs + Find Security Bugs (Maven)
```xml
<plugin>
  <groupId>com.github.spotbugs</groupId>
  <artifactId>spotbugs-maven-plugin</artifactId>
  <version>4.8.3.1</version>
  <configuration>
    <plugins>
      <plugin>
        <groupId>com.h3xstream.findsecbugs</groupId>
        <artifactId>findsecbugs-plugin</artifactId>
        <version>1.13.0</version>
      </plugin>
    </plugins>
    <effort>Max</effort>
    <threshold>Medium</threshold>
  </configuration>
</plugin>
```

### OWASP Dependency-Check (Maven)
```xml
<plugin>
  <groupId>org.owasp</groupId>
  <artifactId>dependency-check-maven</artifactId>
  <version>12.2.0</version>
  <configuration>
    <failBuildOnCVSS>7</failBuildOnCVSS>
  </configuration>
</plugin>
```

### Semgrep (CI)
```bash
# Install
pip install semgrep

# Run with OWASP rules + custom rules
semgrep --config p/owasp-top-ten --config .semgrep/ .
```

### CodeQL (GitHub Actions)
```yaml
- uses: github/codeql-action/init@v3
  with:
    languages: java
    queries: security-extended
- uses: github/codeql-action/autobuild@v3
- uses: github/codeql-action/analyze@v3
```
