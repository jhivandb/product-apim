# Vulnerability Scanning Plan for WSO2 API Manager

## Table of Contents

1. [Codebase Context](#1-codebase-context)
2. [Attack Surface Summary](#2-attack-surface-summary)
3. [Tool Evaluation Matrix](#3-tool-evaluation-matrix)
4. [Recommended Approach: Layered Scanning Strategy](#4-recommended-approach-layered-scanning-strategy)
5. [Option A: Open-Source Stack](#option-a-open-source-stack-0year)
6. [Option B: Mid-Tier Commercial + Open-Source Hybrid](#option-b-mid-tier-commercial--open-source-hybrid)
7. [Option C: Enterprise Commercial Stack](#option-c-enterprise-commercial-stack)
8. [Encoding Past Vulnerability Examples (Custom Rules)](#6-encoding-past-vulnerability-examples-custom-rules)
9. [Multi-Repository Scanning Strategy](#7-multi-repository-scanning-strategy)
10. [CI/CD Integration Architecture](#8-cicd-integration-architecture)
11. [Coverage Gap Analysis](#9-coverage-gap-analysis)
12. [Recommendation](#10-recommendation)

---

## 1. Codebase Context

Based on analysis of the `product-apim` repository:

| Dimension                | Details |
|--------------------------|---------|
| **Primary Language**     | Java (source 1.8 compat, CI runs JDK 11) |
| **Build System**         | Maven multi-module (4 top-level modules: api-control-plane, gateway, traffic-manager, all-in-one-apim) |
| **Frameworks**           | Spring 5.1.x, Apache CXF 3.6.x (JAX-RS), Axis2, Apache Synapse, Tomcat Embedded |
| **ORM / DB Access**      | Hibernate, JDBC (H2 dev, multiple datasources: WSO2_CARBON_DB, WSO2AM_DB, WSO2AM_STATS_DB, WSO2_SHARED_DB) |
| **Auth/AuthZ**           | OAuth2, OIDC, SAML 2.0, Mutual TLS, JWT (Nimbus JOSE), Carbon Identity Framework |
| **XML Parsing**          | AXIOM, JAXB, StAX (via Axis2), Apache Santuario, OpenSAML |
| **Existing Security**    | OWASP CSRFGuard (configured), WSS4J, Bouncy Castle, Apache XML Security |
| **CI/CD**                | GitHub Actions (maven.yml), Codecov for coverage |
| **Dependent Repos**      | 5-15 WSO2 component repositories pulled via Maven (carbon-apimgt, carbon-identity-framework, etc.) |
| **JSON Libraries**       | Jackson 2.16.x, Gson, JSON-Simple, JSON-Smart, JSONPath |
| **HTTP Clients**         | OkHttp 4.12, Apache HttpClient, Jersey |

---

## 2. Attack Surface Summary

Given the architecture, these are the priority vulnerability classes to scan for:

### Tier 1 - Critical (Direct exploit paths in an API Gateway)

| Vulnerability         | Where It Lives in This Codebase |
|-----------------------|-------------------------------|
| **SQL Injection**     | JDBC calls in Carbon DB layer, custom DAO classes, Hibernate HQL. Multiple datasources with raw connection pools. |
| **XXE Injection**     | AXIOM/JAXB/StAX XML parsing in SOAP handlers (Axis2), SAML assertion processing (OpenSAML), API payload mediation (Synapse). |
| **SSRF**              | API Gateway proxying, backend endpoint calls via OkHttp/HttpClient, mediation sequences. |
| **Auth Bypass / Privilege Escalation** | OAuth2 token validation logic, scope enforcement, role checks in Carbon Identity, API key validation. |
| **Insecure Deserialization** | Java object deserialization in message passing, OSGI bundle communication, Axis2 SOAP handling. |

### Tier 2 - High

| Vulnerability         | Where It Lives |
|-----------------------|---------------|
| **CSRF**              | CSRFGuard is configured but coverage gaps may exist (unprotected endpoints, token validation bypasses). |
| **XSS**               | Admin/Publisher/DevPortal UIs (JSP, JavaScript), error messages reflected in responses. |
| **Path Traversal**    | File-based API artifact storage, deployment artifact handling, log file access. |
| **LDAP Injection**    | User store lookups via Carbon User Manager. |

### Tier 3 - Medium

| Vulnerability         | Where It Lives |
|-----------------------|---------------|
| **Hardcoded Secrets** | Configuration files, test fixtures, embedded credentials. |
| **Weak Cryptography** | Bouncy Castle usage, TLS configuration, token signing algorithms. |
| **Race Conditions**   | Concurrent API subscription handling, token revocation. |
| **Known CVEs in Dependencies** | 100+ transitive dependencies via Maven, many WSO2-patched forks. |

---

## 3. Tool Evaluation Matrix

### SAST Tools (Source Code Analysis)

| Tool | Analysis Type | Cross-File Taint | Custom Rules | Java Quality | Cost | Best For |
|------|:------------:|:----------------:|:------------:|:------------:|------|----------|
| **Semgrep Pro** | Semantic + Pattern | Yes (Pro) | Yes (YAML DSL) | Very High | Free CE; $40/dev/mo | Best balance of power, usability, and cost |
| **CodeQL** | Full Semantic (DB-based) | Yes | Yes (QL language) | Excellent | Free (public repos) / GHAS | Deepest free semantic analysis |
| **SonarQube** | Semantic + Taint | Yes (Dev+) | Limited (src/sink config) | Very High | Free Community; $2.5K+/yr Dev | Code quality + security in one |
| **Snyk Code** | AI/ML Semantic | Yes | No | Good | Free limited; $25/dev/mo | AI-driven novel pattern detection |
| **Checkmarx One** | Full Semantic | Yes | Yes (CxQL + AI Builder) | Excellent | ~$59K+/yr | Enterprise, compliance-driven orgs |
| **Fortify** | Full Semantic | Yes | Yes (XML rules) | Excellent | Enterprise (contact sales) | Regulated industries, gov compliance |
| **SpotBugs + FindSecBugs** | Bytecode Pattern | No (intra-method only) | Yes (Java API) | Excellent | Free (LGPL) | Free baseline, catches low-hanging fruit |
| **Joern** | Code Property Graph | Yes | Yes (Scala DSL) | Good | Free (Apache 2.0) | Research, novel vuln discovery |

### SCA Tools (Dependency Scanning) - Complementary Layer

| Tool | What It Scans | Custom Rules | Cost |
|------|---------------|:------------:|------|
| **OWASP Dependency-Check** | Maven deps against NVD | Suppression files only | Free |
| **Trivy** | Deps, containers, IaC, secrets | Rego (IaC only) | Free |
| **Snyk Open Source** | Deps with reachability analysis | No | Free limited; paid tiers |

---

## 4. Recommended Approach: Layered Scanning Strategy

No single tool covers everything. The recommended approach layers tools by analysis depth:

```
 Layer 4: Custom/Research Analysis (for historical vuln patterns)
           Joern (CPG) or Semgrep Custom Rules or CodeQL Custom Queries
          ┌─────────────────────────────────────────────────────────┐
 Layer 3: │ Deep Semantic SAST (cross-file taint analysis)         │
          │ Semgrep Pro  OR  CodeQL  OR  SonarQube Dev+            │
          ├─────────────────────────────────────────────────────────┤
 Layer 2: │ Bytecode-Level Security Scanning                       │
          │ SpotBugs + Find Security Bugs (free, 144 vuln types)   │
          ├─────────────────────────────────────────────────────────┤
 Layer 1: │ Dependency / SCA Scanning                              │
          │ OWASP Dependency-Check + Trivy                         │
          └─────────────────────────────────────────────────────────┘
```

Each layer catches different things:
- **Layer 1** catches known CVEs in your 100+ transitive dependencies (especially critical given WSO2-patched forks)
- **Layer 2** catches common patterns in compiled bytecode (cheap, fast, zero false-negative baseline)
- **Layer 3** finds complex multi-step vulnerabilities where tainted data flows across classes and packages
- **Layer 4** encodes your organization's past vulnerability examples into reusable detection rules

---

## Option A: Open-Source Stack ($0/year)

**Tools: CodeQL + SpotBugs/FindSecBugs + OWASP Dependency-Check + Trivy**

### Strengths
- **CodeQL** provides full cross-file taint analysis with the industry's most expressive custom query language (QL). Covers SQL injection, XXE, SSRF, deserialization, CSRF, and more out of the box. Excellent Java support including Spring/JAX-RS library models.
- **SpotBugs + Find Security Bugs** adds fast bytecode scanning (144 vuln types, 826+ API signatures) as a Maven build step. Catches issues CodeQL might miss at the bytecode level.
- **OWASP Dependency-Check** scans all Maven dependencies against NVD. Critical for a project with many WSO2-forked dependencies.
- **Trivy** adds container image scanning and secrets detection.

### Weaknesses
- CodeQL requires GitHub Advanced Security for private repos (free for public repos only). If product-apim is private, this becomes the GHAS pricing tier.
- CodeQL build times can be significant for large codebases (15-45 min for a codebase this size).
- No AI/ML-driven detection - all rules are hand-authored.
- Custom CodeQL queries have a steep learning curve (QL is a logic programming language).

### Coverage for Target Vulnerability Classes

| Vulnerability | CodeQL | FindSecBugs | OWASP DC | Combined |
|---------------|:------:|:-----------:|:--------:|:--------:|
| SQL Injection | Deep taint tracking across DAO layers | Intra-method JDBC/HQL patterns | Known CVEs in DB drivers | Strong |
| XXE           | Tracks XML parser config to parse calls | Detects unsafe XMLReader/DocumentBuilder | Known CVEs in XML libs | Strong |
| SSRF          | Tracks user input to HTTP client calls | Limited (no cross-method) | Known CVEs in HTTP libs | Moderate-Strong |
| Privilege Escalation | Custom queries needed for auth logic | Not covered | N/A | Requires custom work |
| CSRF          | Detects missing CSRF tokens | Partial detection | N/A | Moderate |
| Deserialization | ObjectInputStream tracking | Detects unsafe deserialization calls | Known CVEs (e.g., Commons Collections) | Strong |
| XSS           | Cross-file source-to-sink | Intra-method reflection | N/A | Strong |
| Path Traversal | User input to file operations | Basic pattern matching | N/A | Moderate-Strong |

### Effort to Set Up
- CodeQL: ~2-3 days (GitHub Actions workflow, initial query tuning, suppression of false positives)
- SpotBugs: ~1 day (Maven plugin config, threshold tuning)
- OWASP Dependency-Check: ~0.5 day (Maven plugin, NVD API key)
- Trivy: ~0.5 day (CI step for container images)
- Custom CodeQL queries for past vulns: ~1-2 weeks per vulnerability class

---

## Option B: Mid-Tier Commercial + Open-Source Hybrid

**Tools: Semgrep Pro (Team) + SonarQube Developer + SpotBugs/FindSecBugs + OWASP Dependency-Check**

### Strengths
- **Semgrep Pro** (Team tier, $40/contributor/month, free for <=10) provides cross-file taint analysis with the most accessible custom rule language (YAML-based, looks like source code). Writing custom rules from past vulnerability examples is significantly easier than CodeQL's QL.
- **SonarQube Developer** ($2,500+/yr) adds continuous code quality + security analysis with branch/PR analysis, quality gates, and a developer-friendly dashboard. Its taint engine is strong for Java.
- **SpotBugs + FindSecBugs** as a free bytecode baseline (same as Option A).
- **OWASP Dependency-Check** for SCA (same as Option A).

### Strengths Over Option A
- Semgrep's custom rule authoring is 5-10x faster than CodeQL for encoding historical vulnerability patterns
- SonarQube provides a single dashboard for both security and code quality, with trend tracking over time
- Semgrep's rules look like the source code they match - easier for Java developers to write and review
- Faster scan times (Semgrep: seconds to minutes; SonarQube: minutes)
- No dependency on GitHub (works with any Git hosting)

### Weaknesses
- Total cost: ~$5,000-15,000/year depending on team size and LOC
- SonarQube's custom rule capability is limited compared to Semgrep/CodeQL (can only configure sources/sinks, not arbitrary patterns)
- Some overlap between Semgrep Pro and SonarQube security rules (both detect SQL injection, XXE, etc.)

### Coverage for Target Vulnerability Classes

| Vulnerability | Semgrep Pro | SonarQube Dev | FindSecBugs | Combined |
|---------------|:-----------:|:-------------:|:-----------:|:--------:|
| SQL Injection | Cross-file taint, Spring/JDBC models | Cross-file taint | Intra-method | Very Strong |
| XXE           | Custom rules for AXIOM/JAXB/StAX | Built-in rules | Parser config detection | Very Strong |
| SSRF          | HTTP client sink tracking | Built-in rules | Limited | Strong |
| Privilege Escalation | Custom rules for auth patterns | Limited | Not covered | Moderate (custom) |
| CSRF          | Custom rules for endpoint protection | Built-in rules | Partial | Strong |
| Deserialization | Taint tracking to deserialization sinks | Built-in rules | Pattern detection | Very Strong |
| XSS           | Cross-file taint | Cross-file taint | Intra-method | Very Strong |
| Path Traversal | File operation sink tracking | Built-in rules | Pattern matching | Very Strong |

### Effort to Set Up
- Semgrep Pro: ~1-2 days (CI integration, rule selection, team onboarding)
- SonarQube Dev: ~2-3 days (server setup, project config, quality profiles, PR decoration)
- SpotBugs: ~1 day (Maven plugin)
- OWASP Dependency-Check: ~0.5 day
- Custom Semgrep rules for past vulns: ~2-5 days per vulnerability class (much faster than CodeQL)

---

## Option C: Enterprise Commercial Stack

**Tools: Checkmarx One OR Fortify + Snyk (Code + Open Source) + Trivy**

### Strengths
- **Checkmarx One** or **Fortify** provides the deepest commercial SAST with the widest vulnerability coverage (1,400+ categories), cross-file taint analysis, and enterprise features (compliance reporting, RBAC, SSO).
- **Checkmarx CxQL + AI Query Builder**: Write custom queries in a dedicated language or describe patterns in natural language and let AI generate the query. Best commercial option for encoding past vulnerability examples.
- **Snyk Code** adds AI/ML-driven detection trained on 25M+ real-world dataflow cases. This is the only tool that genuinely learns vulnerability patterns from historical data (not rule-authored).
- **Snyk Open Source** provides SCA with reachability analysis (tells you if your code actually calls the vulnerable function, not just that you depend on the library).
- **Trivy** for container/IaC scanning.

### Strengths Over Options A & B
- Widest vulnerability coverage (1,400+ categories vs ~144 for FindSecBugs)
- Compliance reporting out of the box (OWASP Top 10, PCI DSS, NIST 800-53, CWE Top 25)
- Snyk Code's AI can detect novel vulnerability variants that no rule-based system would catch
- Checkmarx's AI Query Builder converts natural-language vulnerability descriptions into detection rules
- Professional support, SLAs, and dedicated security research teams maintaining rules
- Fine-grained RBAC, audit trails, and policy enforcement for enterprise security programs

### Weaknesses
- Significant cost: Checkmarx ~$59K+/year, Fortify (contact sales, comparable), Snyk Enterprise ~$10K-70K+/year
- Vendor lock-in concerns (proprietary query languages, proprietary results formats)
- Longer procurement cycles
- Heavier infrastructure requirements

### Coverage for Target Vulnerability Classes

| Vulnerability | Checkmarx/Fortify | Snyk Code | Combined |
|---------------|:-----------------:|:---------:|:--------:|
| SQL Injection | Deep taint, framework-aware | AI-detected patterns | Comprehensive |
| XXE           | Full parser analysis | AI-detected patterns | Comprehensive |
| SSRF          | Full HTTP client tracking | AI-detected patterns | Comprehensive |
| Privilege Escalation | Auth flow analysis + custom CxQL | AI-detected patterns | Strong |
| CSRF          | Framework-aware detection | AI-detected patterns | Strong |
| Deserialization | Deep tracking | AI-detected patterns | Comprehensive |
| XSS           | Full taint analysis | AI-detected patterns | Comprehensive |
| Path Traversal | Full taint analysis | AI-detected patterns | Comprehensive |

### Effort to Set Up
- Checkmarx/Fortify: ~1-2 weeks (procurement, installation, initial scan tuning, false positive triage)
- Snyk: ~1-2 days (SaaS, SCM integration, policy config)
- Trivy: ~0.5 day
- Custom Checkmarx queries: ~1-3 days per vulnerability class (CxQL + AI Query Builder)

---

## 6. Encoding Past Vulnerability Examples (Custom Rules)

This is a critical requirement. Here's how each tool approach handles it:

### Approach 1: Semgrep Custom Rules (Best for accessibility)

Semgrep rules look like the source code they match. Example for a historical SQL injection pattern:

```yaml
rules:
  - id: wso2-sqli-dao-pattern
    message: >
      Unsanitized input from $SOURCE reaches SQL query in DAO layer.
      This matches the pattern from VULN-2024-001.
    severity: ERROR
    languages: [java]
    mode: taint
    options:
      interfile: true
    pattern-sources:
      - patterns:
          - pattern: (HttpServletRequest $REQ).getParameter(...)
      - patterns:
          - pattern: (MessageContext $CTX).getProperty(...)
    pattern-sinks:
      - patterns:
          - pattern: (PreparedStatement $STMT).executeQuery($QUERY)
          # Or raw string concatenation into SQL
      - patterns:
          - pattern: |
              String $QUERY = ... + $TAINTED + ...;
              ...
              $CONN.prepareStatement($QUERY);
    pattern-sanitizers:
      - patterns:
          - pattern: Encoder.forSql(...)
```

**Workflow for encoding past vulnerabilities:**
1. Take the CVE/bug report with the vulnerable code path
2. Identify the source (where user input enters), sink (where the dangerous operation happens), and any missing sanitizer
3. Write a Semgrep taint-mode rule capturing that pattern
4. Test against the known-vulnerable code to confirm detection
5. Add to a private rule registry shared across all repos

**Estimated effort**: 2-4 hours per vulnerability pattern for an engineer familiar with Semgrep.

### Approach 2: CodeQL Custom Queries (Most powerful, steepest learning curve)

```ql
/**
 * @name SQL injection in WSO2 DAO layer
 * @description Detects unsanitized data flowing from HTTP request
 *              parameters to SQL queries via DAO classes.
 * @kind path-problem
 * @problem.severity error
 * @id wso2/sql-injection-dao
 */
import java
import semmle.code.java.dataflow.TaintTracking
import semmle.code.java.dataflow.FlowSources

class DaoSqlInjection extends TaintTracking::Configuration {
  DaoSqlInjection() { this = "DaoSqlInjection" }

  override predicate isSource(DataFlow::Node source) {
    source instanceof RemoteFlowSource
  }

  override predicate isSink(DataFlow::Node sink) {
    exists(MethodAccess ma |
      ma.getMethod().hasName("executeQuery") and
      ma.getMethod().getDeclaringType().hasQualifiedName("java.sql", "Statement") and
      sink.asExpr() = ma.getArgument(0)
    )
  }
}

from DaoSqlInjection config, DataFlow::PathNode source, DataFlow::PathNode sink
where config.hasFlowPath(source, sink)
select sink.getNode(), source, sink,
  "SQL injection: user input from $@ flows to SQL query.",
  source.getNode(), "this user input"
```

**Estimated effort**: 1-2 days per vulnerability pattern for an engineer new to QL; 2-4 hours once proficient.

### Approach 3: Joern CPG Queries (Most flexible, research-oriented)

```scala
// Find paths from HTTP input to SQL execution
val sources = cpg.method.name("getParameter").callIn
val sinks = cpg.method.name("executeQuery").callIn
sinks.reachableBy(sources).flows.l
```

**Best for**: Exploratory analysis when you don't know exactly what pattern to look for. The interactive REPL lets you navigate the code property graph and discover vulnerability variants.

**Estimated effort**: Variable. Very fast for ad-hoc exploration (minutes), longer for production-quality rules.

### Approach 4: Checkmarx AI Query Builder (Easiest for non-experts)

Natural language input:
> "Detect when data from an HTTP request parameter flows into a JDBC PreparedStatement that is constructed with string concatenation instead of parameterized queries, across multiple classes in the org.wso2.carbon.apimgt package."

The AI generates a CxQL query. Requires Checkmarx One license.

### Recommendation for Custom Rules

| If you choose... | Use this for custom rules | Learning curve | Rule authoring speed |
|-------------------|---------------------------|:--------------:|:--------------------:|
| Option A (OSS)    | CodeQL custom queries     | Steep (QL)     | Slow initially       |
| Option B (Hybrid) | Semgrep custom rules      | Low (YAML+Java patterns) | Fast          |
| Option C (Enterprise) | CxQL + AI Query Builder | Low-Medium  | Fast                 |

---

## 7. Multi-Repository Scanning Strategy

The product-apim codebase depends on 5-15 WSO2 component repositories (carbon-apimgt, carbon-identity-framework, carbon-kernel, etc.). Vulnerabilities often span repository boundaries - e.g., user input enters through product-apim but hits a dangerous sink in carbon-apimgt.

### Strategy 1: Mono-Scan (Scan Dependencies As Source)

```
┌─────────────────────────────────────────────────┐
│ Build product-apim (mvn install)                │
│ → All dependency source JARs resolved           │
│ → Feed entire classpath to scanner              │
│                                                 │
│ CodeQL:  Builds database from all resolved code │
│ Semgrep: Scans source dirs + dependency sources │
│ Fortify: Translates all source in classpath     │
└─────────────────────────────────────────────────┘
```

**Pros**: Catches cross-repository taint flows. A single scan.
**Cons**: Very large scan scope, longer scan times. Requires source JARs for all deps.

### Strategy 2: Per-Repo Scan with Shared Configuration

```
┌──────────────┐  ┌──────────────┐  ┌──────────────┐
│ product-apim │  │carbon-apimgt │  │carbon-identity│
│   + rules    │  │   + rules    │  │   + rules    │
│   + config   │  │   + config   │  │   + config   │
└──────┬───────┘  └──────┬───────┘  └──────┬───────┘
       │                 │                 │
       └────────┬────────┴────────┬────────┘
                │                 │
         ┌──────┴──────┐  ┌──────┴──────┐
         │ Shared Rule │  │ Central     │
         │ Repository  │  │ Dashboard   │
         └─────────────┘  └─────────────┘
```

**Pros**: Faster per-scan. Each repo team owns their findings. Scales independently.
**Cons**: Misses cross-repository taint flows. Requires a shared rules repo.

### Strategy 3: Hybrid (Recommended)

- **Per-repo scans** (Strategy 2) for fast CI feedback on every PR
- **Periodic mono-scans** (Strategy 1, e.g., weekly/nightly) for cross-repo flow analysis
- **Shared custom rule repository** versioned and distributed to all repos
- **Central dashboard** (SonarQube, Semgrep AppSec Platform, or GitHub Security Overview) for aggregate view

---

## 8. CI/CD Integration Architecture

Building on the existing GitHub Actions workflow (`maven.yml`):

```yaml
# .github/workflows/security-scan.yml (conceptual)
name: Security Scanning

on:
  pull_request:
    branches: [master]
  schedule:
    - cron: '0 2 * * 1'  # Weekly deep scan (Monday 2am)

jobs:
  # Layer 1: Dependency scanning (fast, ~2-5 min)
  dependency-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: OWASP Dependency-Check
        uses: dependency-check/Dependency-Check_Action@main
        with:
          project: 'product-apim'
          path: '.'
          format: 'HTML'
          args: '--failOnCVSS 7'
      - name: Trivy filesystem scan
        uses: aquasecurity/trivy-action@master
        with:
          scan-type: 'fs'
          severity: 'CRITICAL,HIGH'

  # Layer 2: Bytecode scan (medium, ~5-10 min, runs after build)
  spotbugs-scan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - name: Build and run SpotBugs + FindSecBugs
        run: mvn clean compile spotbugs:check -Dspotbugs.plugins=com.h3xstream.findsecbugs:findsecbugs-plugin

  # Layer 3: Semantic SAST (choose one based on option)
  semgrep-scan:  # Option B
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: semgrep/semgrep-action@v1
        with:
          config: >-
            p/java
            p/owasp-top-ten
            .semgrep/  # Custom rules directory
        env:
          SEMGREP_APP_TOKEN: ${{ secrets.SEMGREP_APP_TOKEN }}

  codeql-scan:  # Option A
    runs-on: ubuntu-latest
    permissions:
      security-events: write
    steps:
      - uses: actions/checkout@v4
      - uses: github/codeql-action/init@v3
        with:
          languages: java
          queries: security-extended,./codeql-queries/  # Custom query packs
      - uses: github/codeql-action/autobuild@v3
      - uses: github/codeql-action/analyze@v3

  # Layer 4: Nightly deep scan (cross-repo, historical patterns)
  deep-scan:
    if: github.event_name == 'schedule'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout all WSO2 component repos
        run: |
          # Clone dependent repos for cross-repo analysis
          # Run Joern CPG analysis or expanded Semgrep/CodeQL scan
```

### Gate Strategy

| Scan Layer | PR Gate? | Failure Behavior |
|------------|:--------:|------------------|
| Dependency (CVSS >= 7) | Yes, blocking | Fail PR check |
| SpotBugs (HIGH/CRITICAL) | Yes, blocking | Fail PR check |
| Semantic SAST (new findings only) | Yes, blocking on CRITICAL; warning on HIGH | Annotate PR, block on critical |
| Deep cross-repo scan | No (nightly) | Create Jira tickets / GitHub issues |

---

## 9. Coverage Gap Analysis

Even with the best tooling, some vulnerability classes need manual attention:

| Gap | Why Tools Struggle | Mitigation |
|-----|-------------------|------------|
| **Business logic privilege escalation** | Tools can track data flow but can't understand authorization intent (e.g., "only admin should access this endpoint") | Custom rules encoding specific auth patterns + manual code review of auth-related changes |
| **CSRF in single-page-app flows** | CSRFGuard is configured but SPA token refresh patterns are hard to model statically | Manual review of SPA API calls + integration tests verifying CSRF token enforcement |
| **Race conditions in token handling** | Static analysis cannot reason about concurrent execution timing | Concurrency-focused code review + targeted dynamic testing (DAST) |
| **Configuration-based vulnerabilities** | XML configs (datasources, security configs) may introduce vulns not visible in code | Config scanning rules (Semgrep can match XML patterns), Trivy misconfiguration scanning |
| **WSO2-specific auth bypass patterns** | Generic tools don't understand WSO2 Carbon's custom auth pipeline | Custom rules based on historical WSO2 CVEs (this is where your past vulnerability examples are critical) |

### Recommended Supplementary Measures

1. **DAST (Dynamic Application Security Testing)**: Run OWASP ZAP or Burp Suite against deployed instances for runtime validation
2. **Manual Penetration Testing**: Annual or per-release for business logic and auth bypass
3. **Threat Modeling**: Document data flows and trust boundaries for the API Gateway, especially auth token flows
4. **Security-Focused Code Review Checklist**: For PRs touching auth, XML parsing, SQL, or HTTP client code

---

## 10. Recommendation

### For most teams: Option B (Semgrep Pro + SonarQube Dev + SpotBugs + OWASP DC)

**Why:**
1. **Custom rules from past vulns are easiest in Semgrep** - YAML rules look like source code, can be authored by Java developers without learning a new language
2. **SonarQube provides a unified quality + security dashboard** with trend tracking, which helps track remediation progress across all repos
3. **SpotBugs is free and catches low-hanging fruit** that the other tools might skip at the bytecode level
4. **Cost is reasonable**: ~$5K-15K/year depending on team size, vs $60K+ for enterprise tools
5. **Fast feedback loop**: Semgrep scans in seconds on PRs; SonarQube in minutes

### If budget is zero: Option A (CodeQL + SpotBugs + OWASP DC)

CodeQL is the most powerful free semantic analysis tool. The learning curve for custom QL queries is steep but the expressiveness is unmatched. If the codebase is public or you have GitHub Advanced Security, this is the strongest free option.

### If compliance/regulation demands it: Option C (Checkmarx + Snyk)

For organizations with PCI DSS, SOC 2, or regulatory requirements that mandate specific SAST tooling, Checkmarx or Fortify provide the compliance reporting and audit trails needed. Snyk Code's AI adds a unique detection layer that no other tool provides.

### Phased Rollout Plan

| Phase | Timeline | Actions |
|-------|----------|---------|
| **Phase 1** | Week 1-2 | Add OWASP Dependency-Check + SpotBugs/FindSecBugs to CI (free, immediate value) |
| **Phase 2** | Week 3-4 | Add Semgrep CE or CodeQL to CI for semantic scanning. Begin writing custom rules from past vulnerability examples. |
| **Phase 3** | Month 2 | Evaluate Semgrep Pro or SonarQube Developer for cross-file taint analysis. Run trial scans, measure false positive rate. |
| **Phase 4** | Month 3 | Roll out to all dependent repositories with shared rule configuration. Set up central dashboard. |
| **Phase 5** | Ongoing | Encode each new vulnerability discovered into custom rules. Build organizational vulnerability knowledge base. |

---

## Appendix: Quick Reference - Tool Installation

### SpotBugs + Find Security Bugs (Maven)
```xml
<plugin>
  <groupId>com.github.spotbugs</groupId>
  <artifactId>spotbugs-maven-plugin</artifactId>
  <version>4.8.3.1</version>
  <configuration>
    <plugins>
      <plugin>
        <groupId>com.h3xstream.findsecbugs</groupId>
        <artifactId>findsecbugs-plugin</artifactId>
        <version>1.13.0</version>
      </plugin>
    </plugins>
    <effort>Max</effort>
    <threshold>Medium</threshold>
  </configuration>
</plugin>
```

### OWASP Dependency-Check (Maven)
```xml
<plugin>
  <groupId>org.owasp</groupId>
  <artifactId>dependency-check-maven</artifactId>
  <version>12.2.0</version>
  <configuration>
    <failBuildOnCVSS>7</failBuildOnCVSS>
  </configuration>
</plugin>
```

### Semgrep (CI)
```bash
# Install
pip install semgrep

# Run with OWASP rules + custom rules
semgrep --config p/owasp-top-ten --config .semgrep/ .
```

### CodeQL (GitHub Actions)
```yaml
- uses: github/codeql-action/init@v3
  with:
    languages: java
    queries: security-extended
- uses: github/codeql-action/autobuild@v3
- uses: github/codeql-action/analyze@v3
```

---

## Appendix B: Identified Attack Surface Layers & Claude-Based Scanning Strategy

This section maps the concrete code layers where security bypasses are most likely, and
describes how to use Claude Code with context files (CLAUDE.md) to perform targeted
semantic security reviews of each layer.

### Architecture: Where the Code Actually Lives

A critical finding from codebase analysis: **product-apim is a distribution/integration
repo**. The core implementation logic lives in external Maven dependencies:

```
┌─────────────────────────────────────────────────────────────────────┐
│                     product-apim (THIS REPO)                        │
│  ┌───────────────┐ ┌───────────┐ ┌────────────┐ ┌───────────────┐  │
│  │ api-control-  │ │  gateway  │ │  traffic-  │ │ all-in-one-   │  │
│  │ plane         │ │           │ │  manager   │ │ apim          │  │
│  └───────┬───────┘ └─────┬─────┘ └─────┬──────┘ └──────┬────────┘  │
│          │               │             │               │           │
│          │  Configuration, integration tests, distribution         │
│          │  packaging, sample services, admin clients              │
└──────────┼───────────────┼─────────────┼───────────────┼───────────┘
           │               │             │               │
    ┌──────┴───────────────┴─────────────┴───────────────┴──────┐
    │              EXTERNAL DEPENDENCY REPOS                     │
    │                                                            │
    │  carbon-apimgt          ← DAO layer, REST APIs, gateway   │
    │  │                        handlers, token validation,      │
    │  │                        publisher/store/admin APIs        │
    │  │                                                         │
    │  carbon-identity-       ← OAuth2 server, scope validator,  │
    │  framework                SAML processing, user store,     │
    │  │                        XACML authorization engine        │
    │  │                                                         │
    │  carbon-kernel          ← User manager, registry, JDBC     │
    │  │                        user store, tenant management     │
    │  │                                                         │
    │  carbon-commons         ← Shared utilities                  │
    │  carbon-mediation       ← Synapse mediators, message proc  │
    │  carbon-governance      ← API governance, lifecycle        │
    └────────────────────────────────────────────────────────────┘
```

**Implication for scanning**: The most dangerous code (DAOs, auth handlers, gateway
request processing) lives in `carbon-apimgt` and `carbon-identity-framework`, not in
this repo. Scanning product-apim alone covers ~20% of the real attack surface.

---

### Layer 1: Auth Handling (Highest Bypass Risk)

**What was found in this repo:**

| Component | Location | Risk |
|-----------|----------|------|
| Token issuer config | `APIMTokenIssuer`, `ExtendedJWTBearerGrantHandler` in keymgt deps | Token forging, scope bypass |
| Scope validation | `XACMLScopeValidator` (XACML-based, disabled in APIM 4.6+) | Scope enforcement gaps |
| XACML engine config | `balana-config.xml` in gateway/api-cp/all-in-one `conf/security/` | Policy misconfiguration |
| Third-party KeyManager | `ThirdPartyKmConnector.java` (test extension) | Insecure KM integration patterns |
| Gateway auth sequences | `_auth_failure_handler_.xml`, `_token_fault_.xml`, `_production_key_error_.xml` | Error handling leaks |
| OPA integration | `_opa_policy_failure_handler_.xml` | Policy bypass on failure |
| Thrift session DAO | `DBThriftSessionDAO`, `InMemoryThriftSessionDAO` configs | Session fixation |
| Admin stub auth | `AuthenticateStub.java`, `AuthenticateStubUtil.java` | Credential handling |

**Where the critical auth logic actually lives (in dependency repos):**
- `org.wso2.carbon.apimgt.gateway.handlers.*` - Gateway authentication/authorization handlers
- `org.wso2.carbon.apimgt.keymgt.*` - Key management, token validation
- `org.wso2.carbon.identity.oauth2.*` - OAuth2 token issuance/validation
- `org.wso2.carbon.identity.application.authentication.*` - Authentication framework
- `org.wso2.carbon.user.core.jdbc.*` - JDBC user store manager

---

### Layer 2: Database / DAO Layer

**What was found in this repo:**

| Component | Location | Risk |
|-----------|----------|------|
| UserStore SQL templates | `secondary.xml` (test config) | All use parameterized `?` placeholders (GOOD) |
| Datasource config | `master-datasources.xml` (4 copies across modules) | Connection pool settings, credential exposure |
| DB connection pools | WSO2_CARBON_DB, WSO2AM_DB, WSO2AM_STATS_DB, WSO2_SHARED_DB, WSO2_MB_STORE_DB | Multiple attack surfaces |

**No raw SQL construction or JDBC code was found in this repo.** All DAO implementation
is in `carbon-apimgt` (`org.wso2.carbon.apimgt.impl.dao.*`) and `carbon-kernel`
(`org.wso2.carbon.user.core.jdbc.*`).

**What to scan in dependency repos:**
- `ApiMgtDAO.java` - Main API Manager DAO (likely 5,000+ LOC)
- `SubscriptionDAO`, `ApplicationDAO`, `PolicyDAO` - Domain-specific DAOs
- `UniqueIDJDBCUserStoreManager` - User store with SQL queries
- Any class using `Connection.prepareStatement()` or `Statement.execute*()`

---

### Layer 3: XML Parsing (XXE Attack Surface)

**11 vulnerable files found in this repo - NONE have XXE protections:**

| File | Parser | Vulnerability |
|------|--------|---------------|
| `SynapseConfigAdminClient.java` | `DocumentBuilderFactory` + `XMLInputFactory` + `TransformerFactory` | **CRITICAL**: No DTD/external entity protection on any of 3 parser types |
| `EndPointAdminClient.java` | `XMLInputFactory` | No `IS_SUPPORTING_EXTERNAL_ENTITIES=false` |
| `SequenceAdminServiceClient.java` | `XMLInputFactory` | Same |
| `LocalEntriesAdminClient.java` | `XMLInputFactory` | Same |
| `MessageProcessorClient.java` | `XMLInputFactory` | Same |
| `PriorityMediationAdminClient.java` | `XMLInputFactory` | Same |
| `TaskAdminClient.java` | `XMLInputFactory` | Same |
| `EndpointTemplateAdminServiceClient.java` | `XMLInputFactory` | Same |
| `SequenceTemplateAdminServiceClient.java` | `XMLInputFactory` | Same |
| `APIMTestCaseUtils.java` | `XMLInputFactory` | Same |
| `SoapToRestTestCase.java` | `XMLInputFactory` | Same |

All located under:
```
all-in-one-apim/modules/integration/tests-common/admin-clients/src/main/java/
org/wso2/am/admin/clients/
```

**Data flow pattern** (all follow the same pattern):
```
DataHandler.getInputStream() → XMLInputFactory.newInstance()  ← NO PROTECTION
    → createXMLStreamReader() → StAXOMBuilder → OMElement → Admin Stub
```

---

### Layer 4: HTTP Client / SSRF Surface

**Found in this repo:**

| Client | Usage Location | Risk |
|--------|---------------|------|
| OkHttp `ApiClient.java` | 7+ generated client classes (admin, publisher, store, gateway, etc.) | URL constructed from `basePath + path + queryParams` with no SSRF validation |
| Apache HttpClient | `HTTPSClientUtils.java` (sample utils) | `doGet/doPost/doPut` with no URL validation |
| `HttpURLConnection` | `HttpRequestUtil.java`, ApiClient OAuth flows | `new URL(endpoint).openConnection()` with no protocol/host allowlist |
| Backend endpoint DTOs | `APIEndpointDTO`, `BackendDTO`, `EndpointDTO` | User-configurable backend URLs stored as strings |

**Key SSRF risk**: The gateway proxies requests to user-configured backend endpoints.
A `BackendDTO.url` set to `http://169.254.169.254/latest/meta-data/` (AWS IMDS) or
`file:///etc/passwd` could be exploited if the gateway doesn't validate URLs before
forwarding.

---

### Layer 5: Input Entry Points

| Entry Mechanism | Technology | Example Classes |
|----------------|------------|-----------------|
| REST API endpoints | JAX-RS / CXF | `PeopleRestService`, `CustomerService`, `StarbucksOutletService`, `ApiInformationService` |
| Servlet endpoints | `HttpServlet` | `CallbackServerServlet` (WebSub receiver) |
| WebSocket messages | Jetty WebSocket | `WebSocketServerImpl` |
| HTTP utilities | Apache HttpClient | `HttpRequestUtil` |
| XML config deployment | Admin stubs | All admin client classes (endpoints, sequences, tasks, templates) |

**Specific concern**: `PeopleRestService.java` takes `@QueryParam` and `@FormParam`
values that flow directly to service methods without validation. The `@PathParam("email")`
is used as a lookup key and in URI construction (`uriInfo.getRequestUriBuilder().path(email).build()`).

---

### Claude-Based Scanning Strategy: Using CLAUDE.md Context Files

The core idea: **use Claude Code as a semantic security reviewer** by providing it with
vulnerability context, code examples from past incidents, and structured scanning prompts.
Claude can understand business logic, authentication intent, and data flow semantics
that static tools cannot.

#### Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                   Security Context Files                        │
│                                                                 │
│  CLAUDE.md (root)                                               │
│  ├── .claude/security/                                          │
│  │   ├── vuln-knowledge-base.md    ← Past vulnerability examples│
│  │   ├── auth-patterns.md          ← Auth bypass patterns       │
│  │   ├── scanning-prompts.md       ← Reusable review prompts    │
│  │   └── safe-patterns.md          ← Known-safe patterns        │
│  │                                                              │
│  ├── .claude/layers/                                            │
│  │   ├── layer-auth.md             ← Auth layer file manifest   │
│  │   ├── layer-dao.md              ← DAO layer file manifest    │
│  │   ├── layer-xml.md              ← XML parsing file manifest  │
│  │   ├── layer-http.md             ← HTTP client file manifest  │
│  │   └── layer-input.md            ← Input handling manifest    │
│  │                                                              │
│  └── Shared across all repos via git submodule or copy          │
└─────────────────────────────────────────────────────────────────┘
```

#### File 1: CLAUDE.md (Project Root)

```markdown
# Security Review Context

This project is WSO2 API Manager - a security-critical API gateway and
management platform. All code changes should be reviewed with the
following security concerns in mind.

## Security-Critical Layers

When reviewing code in these areas, apply heightened security scrutiny:

1. **Auth Handling** - See .claude/layers/layer-auth.md
2. **Database/DAO** - See .claude/layers/layer-dao.md
3. **XML Parsing** - See .claude/layers/layer-xml.md
4. **HTTP Clients** - See .claude/layers/layer-http.md
5. **Input Handling** - See .claude/layers/layer-input.md

## Known Vulnerability Patterns

See .claude/security/vuln-knowledge-base.md for examples of past
vulnerabilities found in this codebase. When reviewing code, check
for these patterns and their variants.

## Review Standards

- Every XML parser MUST disable external entities and DTDs
- Every SQL query MUST use parameterized statements (never string concat)
- Every outbound HTTP call MUST validate the target URL against an allowlist
- Every REST endpoint with state-changing operations MUST enforce CSRF protection
- Every auth check MUST be positive (deny by default, explicitly allow)
```

#### File 2: .claude/security/vuln-knowledge-base.md

This is where you encode your past vulnerability examples:

```markdown
# Vulnerability Knowledge Base

## Format
Each entry follows: Vulnerability ID, class, code example (before/after),
detection heuristic, and affected components.

## VULN-001: XXE via Unprotected XMLInputFactory

**Class**: XXE Injection (CWE-611)
**Severity**: Critical
**Affected Pattern**: Any use of XMLInputFactory.newInstance() without
disabling external entities.

**Vulnerable Code Example** (from SynapseConfigAdminClient.java):
```java
// VULNERABLE - no XXE protection
XMLStreamReader reader = XMLInputFactory.newInstance()
    .createXMLStreamReader(new StringReader(xml));
StAXOMBuilder builder = new StAXOMBuilder(reader);
```

**Fixed Code Example**:
```java
// SAFE - external entities disabled
XMLInputFactory factory = XMLInputFactory.newInstance();
factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);
XMLStreamReader reader = factory.createXMLStreamReader(new StringReader(xml));
StAXOMBuilder builder = new StAXOMBuilder(reader);
```

**Detection Heuristic**: Look for XMLInputFactory.newInstance() NOT followed by
setProperty(IS_SUPPORTING_EXTERNAL_ENTITIES, false) before createXMLStreamReader().

---

## VULN-002: SSRF via Unvalidated Backend URLs

**Class**: Server-Side Request Forgery (CWE-918)
**Severity**: High
**Affected Pattern**: HTTP clients that accept user-configurable endpoint
URLs without protocol/host validation.

**Vulnerable Code Example** (from HttpRequestUtil.java):
```java
// VULNERABLE - endpoint URL not validated
URL url = new URL(urlStr);
HttpURLConnection conn = (HttpURLConnection) url.openConnection();
```

**Detection Heuristic**: Look for URL construction from variables that
originate from user input, configuration, or API definitions, without
URL validation (protocol allowlist, host allowlist, private IP blocking).

---

## VULN-003: SQL Injection via String Concatenation in DAO

**Class**: SQL Injection (CWE-89)
**Severity**: Critical
**Affected Pattern**: String concatenation in SQL query construction
instead of parameterized PreparedStatement.

**Vulnerable Code Example** (template - adapt from actual past vulns):
```java
// VULNERABLE - string concatenation in SQL
String query = "SELECT * FROM AM_API WHERE API_NAME = '" + apiName + "'";
Statement stmt = connection.createStatement();
ResultSet rs = stmt.executeQuery(query);
```

**Fixed Code Example**:
```java
// SAFE - parameterized query
String query = "SELECT * FROM AM_API WHERE API_NAME = ?";
PreparedStatement stmt = connection.prepareStatement(query);
stmt.setString(1, apiName);
ResultSet rs = stmt.executeQuery();
```

**Detection Heuristic**: Look for String variables containing SQL keywords
(SELECT, INSERT, UPDATE, DELETE, WHERE) that are constructed with + operator
and passed to executeQuery/executeUpdate/prepareStatement.

---

## VULN-004: Auth Bypass via Missing Scope Check

**Class**: Privilege Escalation (CWE-862)
**Severity**: Critical
**Affected Pattern**: REST API endpoint that performs a privileged operation
without verifying the caller's OAuth scope or role.

**Detection Heuristic**: Look for JAX-RS endpoints (@Path, @GET, @POST, etc.)
that modify resources (create, update, delete APIs/subscriptions/policies)
but do NOT call scope validation, role checking, or authorization methods
before the operation.

---

## VULN-005: CSRF on State-Changing Endpoints

**Class**: Cross-Site Request Forgery (CWE-352)
**Severity**: High
**Affected Pattern**: POST/PUT/DELETE endpoints that don't validate
CSRF tokens, especially when CSRFGuard may not cover them.

**Detection Heuristic**: JAX-RS @POST/@PUT/@DELETE endpoints that accept
@FormParam or JSON body but don't reference CSRF token validation.
Check if the endpoint's URL pattern is covered by CSRFGuard configuration
in Owasp.CsrfGuard.Carbon.properties.
```

#### File 3: .claude/layers/layer-auth.md

```markdown
# Layer: Authentication & Authorization

## Scope
All code handling OAuth2 tokens, API keys, scopes, roles, SAML
assertions, mTLS certificates, and session management.

## Files in This Repo

### Gateway Auth Sequences (XML)
- gateway/.../synapse-configs/default/sequences/_auth_failure_handler_.xml
- gateway/.../synapse-configs/default/sequences/_token_fault_.xml
- gateway/.../synapse-configs/default/sequences/_production_key_error_.xml
- gateway/.../synapse-configs/default/sequences/_sandbox_key_error_.xml
- gateway/.../synapse-configs/default/sequences/_resource_mismatch_handler_.xml
- gateway/.../synapse-configs/default/sequences/_opa_policy_failure_handler_.xml

### XACML Configuration
- gateway/.../conf/security/balana-config.xml
- api-control-plane/.../conf/security/balana-config.xml
- all-in-one-apim/.../conf/security/balana-config.xml

### Token/Key Management
- ThirdPartyKmConnector.java (test extension - patterns may be copied)
- AuthenticateStub.java / AuthenticateStubUtil.java
- ApiKeyAuth.java (sample client)
- OAuthOkHttpClient.java (multiple generated copies)
- RetryingOAuth.java (multiple generated copies)

## Files in Dependency Repos (MUST also scan)
- carbon-apimgt: org.wso2.carbon.apimgt.gateway.handlers.*
- carbon-apimgt: org.wso2.carbon.apimgt.keymgt.*
- carbon-identity: org.wso2.carbon.identity.oauth2.*
- carbon-identity: org.wso2.carbon.identity.application.authentication.*
- carbon-kernel: org.wso2.carbon.user.core.jdbc.*

## What to Look For
1. Token validation that can be bypassed (e.g., exception swallowing)
2. Scope checks that are missing or use OR instead of AND
3. Role checks that trust client-supplied role claims
4. Session tokens with predictable values or no expiration
5. Error handlers that leak auth state or token details
6. mTLS validation that doesn't check certificate chain/revocation
```

#### File 4: .claude/layers/layer-xml.md

```markdown
# Layer: XML Parsing (XXE Attack Surface)

## Scope
All code that parses XML from any source, especially user-supplied
XML, SOAP messages, SAML assertions, and API definitions.

## KNOWN VULNERABILITIES IN THIS REPO

### All 11 files below use XMLInputFactory WITHOUT XXE protection:

Admin clients (all under all-in-one-apim/.../admin-clients/):
- endpoint/EndPointAdminClient.java
- sequences/SequenceAdminServiceClient.java
- localentry/LocalEntriesAdminClient.java
- mediation/MessageProcessorClient.java
- mediation/PriorityMediationAdminClient.java
- mediation/SynapseConfigAdminClient.java (ALSO: DocumentBuilderFactory, TransformerFactory)
- tasks/TaskAdminClient.java
- template/EndpointTemplateAdminServiceClient.java
- template/SequenceTemplateAdminServiceClient.java

Test utilities:
- integration-test-utils/.../APIMTestCaseUtils.java
- tests-backend/.../SoapToRestTestCase.java

## Required Fix Pattern
Every XML parser instantiation MUST include:

XMLInputFactory:
  factory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false);
  factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);

DocumentBuilderFactory:
  factory.setFeature("http://apache.org/xml/features/disallow-doctype-decl", true);
  factory.setFeature("http://xml.org/sax/features/external-general-entities", false);
  factory.setFeature("http://xml.org/sax/features/external-parameter-entities", false);

TransformerFactory:
  factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, "");
  factory.setAttribute(XMLConstants.ACCESS_EXTERNAL_STYLESHEET, "");
```

#### File 5: .claude/scanning-prompts.md - Reusable Scanning Prompts

```markdown
# Security Scanning Prompts for Claude Code

## Usage
Run these prompts with Claude Code in the repository root.
Each prompt targets a specific vulnerability class within a specific layer.

---

## Prompt 1: XXE Scanner

Scan all Java files for XML parser instantiation without XXE protection.
Check for: XMLInputFactory, DocumentBuilderFactory, SAXParserFactory,
TransformerFactory, XMLReader, SchemaFactory.

For each instance found:
1. Report the file path and line number
2. Check if external entities / DTD processing is explicitly disabled
3. Trace where the XML input comes from (user-supplied? file? network?)
4. Rate severity: CRITICAL if input is user-supplied, HIGH if from file,
   MEDIUM if from trusted internal source
5. Suggest the specific fix

---

## Prompt 2: SQL Injection Scanner (for dependency repos)

Scan all Java files in the DAO layer for SQL injection patterns.
Look for:
1. String concatenation with SQL keywords (SELECT, INSERT, UPDATE, DELETE, WHERE)
2. String.format() with SQL query templates
3. StringBuilder/StringBuffer used to construct SQL
4. Statement.executeQuery() or executeUpdate() (vs PreparedStatement)
5. HQL/JPQL queries constructed from user input
6. Stored procedure calls with unsanitized parameters

For each finding, trace the data flow backward to determine if the
concatenated value could originate from user input.

---

## Prompt 3: Auth Bypass Scanner

Review all REST API endpoints and check authorization:
1. Find all @Path annotated classes and their methods
2. For each state-changing method (@POST, @PUT, @DELETE):
   a. Is there a scope/role check before the operation?
   b. Is the check using the correct scope (not too permissive)?
   c. Can the check be bypassed by exception handling?
3. For gateway handler sequences:
   a. Can the auth failure handler be exploited to bypass auth?
   b. Does the error response leak token or session information?

---

## Prompt 4: SSRF Scanner

Scan all HTTP client usage for SSRF vulnerabilities:
1. Find all URL/URI construction from variables
2. Trace each URL variable back to its origin:
   - User-supplied (API definition, webhook URL, endpoint config) → CRITICAL
   - Configuration file → HIGH
   - Hardcoded → LOW
3. Check if the URL is validated before the HTTP request:
   - Protocol allowlist (only http/https)?
   - Host allowlist or blocklist (no private IPs, no metadata endpoints)?
   - No file:// or gopher:// protocols?

---

## Prompt 5: CSRF Scanner

Verify CSRF protection coverage:
1. Read Owasp.CsrfGuard.Carbon.properties to understand what's protected
2. Find all @POST/@PUT/@DELETE JAX-RS endpoints
3. Cross-reference: is each endpoint's URL pattern covered by CSRFGuard?
4. Check for endpoints that accept both form data and JSON (CSRFGuard
   may not protect JSON-only endpoints)

---

## Prompt 6: Full Layer Scan (Comprehensive)

Review the files listed in .claude/layers/layer-{name}.md.
For each file:
1. Read the file completely
2. Apply ALL vulnerability checks from the knowledge base
3. Report findings in this format:

   **[SEVERITY] Finding Title**
   - File: path/to/file.java:lineNumber
   - CWE: CWE-XXX
   - Pattern: Which known vulnerability pattern this matches
   - Data Flow: source → ... → sink
   - Recommendation: specific fix
```

#### How to Run Claude Security Scans

**One-shot scan of a specific layer:**
```bash
# Scan the XML parsing layer
claude "Read .claude/layers/layer-xml.md and .claude/security/vuln-knowledge-base.md,
        then scan every file listed in the XML layer manifest. Report all XXE
        vulnerabilities found."

# Scan auth layer
claude "Read .claude/layers/layer-auth.md and .claude/security/vuln-knowledge-base.md,
        then review every auth-related file for bypass patterns. Focus on error
        handlers that might leak auth state and scope checks that might be missing."
```

**Targeted scan with past vulnerability examples:**
```bash
# Provide a past vulnerability and ask Claude to find variants
claude "Here is a vulnerability we found last year: [paste code].
        The issue was [describe]. Search the entire codebase for
        similar patterns or variants of this vulnerability."
```

**PR review with security context:**
```bash
# In a PR review workflow
claude "Review the changes in this PR with security context from
        .claude/security/vuln-knowledge-base.md. Check if any changes
        touch security-critical layers listed in CLAUDE.md. Flag any
        patterns matching known vulnerabilities."
```

**Scan dependency repos (when cloned locally):**
```bash
# Clone and scan carbon-apimgt
git clone https://github.com/wso2/carbon-apimgt.git /tmp/carbon-apimgt
claude "Using the vulnerability patterns in .claude/security/vuln-knowledge-base.md,
        scan the DAO layer in /tmp/carbon-apimgt. Look specifically for:
        1. SQL injection in org.wso2.carbon.apimgt.impl.dao
        2. Missing auth checks in org.wso2.carbon.apimgt.rest.api
        3. XXE in any XML parsing code"
```

#### Advantages of Claude-Based Scanning Over Traditional SAST

| Capability | Traditional SAST | Claude with Context Files |
|------------|:----------------:|:-------------------------:|
| Understands business logic intent | No | Yes - can reason about "should only admin do this?" |
| Learns from paste-in vulnerability examples | Rules must be authored | Yes - paste code and ask "find similar" |
| Cross-repo reasoning | Limited (needs all source) | Yes - can read multiple cloned repos |
| Explains WHY something is vulnerable | Limited (CWE reference) | Detailed natural language explanation |
| Suggests fixes in context | Generic templates | Context-aware fix suggestions |
| Handles WSO2-specific patterns | No built-in rules | Learns from vuln-knowledge-base.md |
| False positive rate | Medium-High | Lower (semantic understanding) |
| Consistency/repeatability | High (deterministic) | Lower (probabilistic) |
| CI/CD automation | Native | Possible via Claude Code CLI |
| Scales to 100K+ LOC | Yes | Limited by context window per session |

#### Limitations and When to Combine with SAST

Claude-based scanning is **not a replacement** for SAST tools. It's a complementary
layer best used for:

1. **Business logic vulnerabilities** that SAST can't detect (auth bypass, privilege
   escalation, insecure workflow)
2. **Novel vulnerability discovery** by providing past examples and asking "find variants"
3. **Deep review of critical changes** to security-sensitive layers
4. **Training data generation** - Claude findings can be encoded into Semgrep/CodeQL rules
   for automated detection going forward

Use SAST tools (Semgrep, CodeQL, SpotBugs) for:
1. **Comprehensive coverage** of all files (Claude reviews are session-scoped)
2. **CI/CD gate enforcement** (deterministic pass/fail)
3. **Dependency vulnerability scanning** (SCA tools)
4. **Regression prevention** (automated checks on every commit)

#### Recommended Combined Workflow

```
 Developer pushes code
         │
         ▼
 ┌─────────────────────────────────────────────────────┐
 │ CI Pipeline (Automated, every PR)                   │
 │                                                     │
 │  1. SpotBugs + FindSecBugs    (bytecode, 2 min)    │
 │  2. Semgrep / CodeQL          (semantic, 5 min)     │
 │  3. OWASP Dependency-Check    (SCA, 3 min)          │
 │                                                     │
 │  → Pass/Fail gate                                   │
 └────────────────────┬────────────────────────────────┘
                      │
         ┌────────────┴────────────┐
         │ PR touches security-    │
         │ critical layer?         │
         │ (auth, DAO, XML, HTTP)  │
         └────────────┬────────────┘
                      │ Yes
                      ▼
 ┌─────────────────────────────────────────────────────┐
 │ Claude Security Review (Triggered, targeted)        │
 │                                                     │
 │  claude "Review this PR diff against the vuln       │
 │  knowledge base in .claude/security/. The changed   │
 │  files touch the [auth|dao|xml|http] layer.         │
 │  Check for patterns matching known vulnerabilities  │
 │  and report any concerns."                          │
 │                                                     │
 │  → Posts review comments on PR                      │
 └─────────────────────────────────────────────────────┘
                      │
                      ▼
 ┌─────────────────────────────────────────────────────┐
 │ Weekly Deep Scan (Scheduled)                        │
 │                                                     │
 │  claude "Perform a full security audit of the       │
 │  [layer] using all prompts in scanning-prompts.md.  │
 │  Clone carbon-apimgt and carbon-identity for        │
 │  cross-repo analysis."                              │
 │                                                     │
 │  → Generates security report                        │
 │  → New findings → encoded into vuln-knowledge-base  │
 │  → New patterns → encoded into Semgrep/CodeQL rules │
 └─────────────────────────────────────────────────────┘
```

This creates a **learning loop**: Claude finds new vulnerability patterns → they get
encoded into the knowledge base and SAST rules → SAST catches them automatically on
every future PR → Claude focuses on finding the next novel pattern.
